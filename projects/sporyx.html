<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sporyx - Blog</title>
    <link rel="stylesheet" href="../css/styles.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.28.0/themes/prism-tomorrow.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet">
    <style>
        .timeline {
            position: relative;
            padding-left: 2rem;
            border-left: 2px solid #dee2e6;
            margin-left: 1rem;
        }

        .timeline article {
            position: relative;
            margin-bottom: 3rem;
        }

        .timeline article::before {
            content: "";
            position: absolute;
            top: 1.5rem;
            left: -1.1rem;
            width: 1rem;
            height: 1rem;
            background-color: #0d6efd;
            border-radius: 50%;
            box-shadow: 0 0 0 4px white;
        }

        .timeline article:last-of-type::before {
            background-color: #00d8a6;
            box-shadow: 0 0 0 4px white, 0 0 10px #00d8a6;
        }

        .btn-floating {
            z-index: 1050;
            border-radius: 50px;
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-expand-lg fixed-top" data-bs-theme="light">
        <div class="container">
            <a class="navbar-brand d-flex align-items-center" href="../index.html#header" aria-label="Accueil">
                <img src="../images/avatar.jpg" width="40" height="40" alt="Avatar Basil L'Hôte"
                    class="rounded-circle me-2">
                <span class="d-none d-md-inline">Basil L'HÔTE</span>
            </a>

            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="../index.html#about">À propos</a></li>
                    <li class="nav-item"><a class="nav-link" href="../index.html#portfolio">Portfolio</a></li>
                    <li class="nav-item"><a class="nav-link" href="../index.html#skills">Compétences</a></li>
                    <li class="nav-item"><a class="nav-link" href="../index.html#contact">Contact</a></li>

                    <li class="nav-item">
                        <button id="theme-toggle" class="btn btn-sm btn-outline-secondary ms-2"
                            aria-label="Changer le thème">
                            <i class="fas fa-moon"></i>
                        </button>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container py-5">
        <h1 class="text-center mb-4 mt-4">Sporyx</h1>
        <p class="text-center text-muted mb-5">Un jeu mobile 3D développé avec Godot. Suivez ici son évolution technique
            et créative.</p>

        <div class="text-center mt-5 mb-5">
            <a href="https://github.com/LBasil/sporyx" target="_blank" class="btn btn-outline-secondary">← Lien vers le
                projet</a>
        </div>

        <section id="blog">
            <h2 class="mb-4">Journal de développement</h2>

            <section id="blog" class="timeline">
                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">Déplacement 3D et vue plongeante dynamique</h3>
                        <button class="btn btn-link toggle-content">
                            <span class="fa fa-chevron-down"></span>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 12 avril 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            Aujourd’hui, j’ai posé les bases du système de déplacement 3D du personnage, ainsi qu’une
                            caméra
                            dynamique en vue plongeante. Ces deux éléments sont essentiels car ils définissent à la fois
                            le
                            gameplay et la sensation de navigation dans l’univers suspendu de <strong>Base-X</strong>.
                        </p>

                        <p>
                            Pour le déplacement, j’utilise un <code>CharacterBody3D</code> dans Godot. L’objectif était
                            d’avoir
                            un mouvement fluide, réactif, mais pas rigide. J’ai donc intégré une accélération avec
                            <code>lerp</code> pour adoucir les transitions, et un système de rotation automatique du
                            personnage
                            dans la direction du mouvement :
                        </p>

                        <pre><code >velocity.x = lerp(velocity.x, direction.x * speed, acceleration * delta)
    rotation.y = lerp_angle(rotation.y, atan2(velocity.x, velocity.z), 10.0 * delta)
                    </code></pre>

                        <p>
                            Ce système permet de créer une vraie inertie dans le contrôle : le personnage ne tourne pas
                            instantanément mais s’oriente progressivement, ce qui est plus naturel en 3D. La gravité est
                            également gérée manuellement pour plus de contrôle, en particulier dans des environnements
                            suspendus
                            où le sol n’est pas toujours garanti.
                        </p>

                        <p>
                            Côté caméra, j’ai mis en place un script simple basé sur un <code>Camera3D</code> qui suit
                            en
                            temps
                            réel le joueur grâce à une référence exportée <code>@export var target: Node3D</code>. La
                            caméra
                            est
                            positionnée avec un décalage (offset) au-dessus et derrière le personnage, pour créer une
                            <strong>vue plongeante</strong> immersive :
                        </p>

                        <pre><code >global_transform.origin = target.global_transform.origin + offset
                    </code></pre>

                        <p>
                            Ce système est léger, adaptable et parfait pour un jeu mobile où la lisibilité est cruciale.
                            La
                            vue
                            plongeante donne une bonne perception de l’environnement tout en gardant le joueur toujours
                            visible
                            et centré.
                        </p>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">Collisions précises avec les murs</h3>
                        <button class="btn btn-link toggle-content">
                            <span class="fa fa-chevron-down"></span>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 13 avril 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            Aujourd’hui, j’ai implémenté un système de collision réaliste entre le joueur et les murs.
                            Jusqu’à
                            présent, le personnage pouvait traverser tout librement, ce qui convenait aux tests de
                            navigation,
                            mais empêchait toute notion de level design. C’est désormais corrigé.
                        </p>

                        <p>
                            Les murs sont modélisés avec des <code>MeshInstance3D</code> (des cubes pour le moment), et
                            chaque
                            mesh est accompagné d’un <code>CollisionShape3D</code> (généralement une boîte) pour gérer
                            les
                            interactions physiques. Ces formes sont simples mais suffisantes pour détecter les chocs et
                            empêcher
                            toute traversée.
                        </p>

                        <p>
                            En pratique, cela change radicalement la sensation de jeu : le joueur sent qu’il évolue dans
                            un
                            espace structuré, avec des limites claires et des contraintes à respecter. C’est aussi la
                            première
                            étape vers des niveaux plus complexes avec des zones fermées, des couloirs, voire des
                            puzzles
                            physiques.
                        </p>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">Essais multijoueur avec Godot</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 14 avril 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            J’ai commencé à expérimenter avec le multijoueur dans Godot pour mieux comprendre comment
                            fonctionne leur système réseau intégré.
                            Même si le projet final utilisera sûrement un serveur plus robuste, je voulais me faire la
                            main
                            sur l'approche
                            "serveur embarqué" de Godot, en mode peer-to-peer avec autorité.
                        </p>

                        <h6>🧪 Architecture de base</h6>

                        <p>
                            J’ai mis en place une logique de client/serveur assez simple avec
                            <code>ENetMultiplayerPeer</code>. Selon si on héberge ou rejoint,
                            on configure le peer comme serveur ou client. Ensuite, on gère les connexions et les
                            déconnexions, et on instancie les joueurs.
                        </p>

                        <pre><code >func start_server():
                  var peer = ENetMultiplayerPeer.new()
                  var error = peer.create_server(PORT, MAX_PLAYERS)
                  if error:
                      print("Erreur serveur : ", error)
                      return
                  multiplayer.multiplayer_peer = peer
                  multiplayer.peer_connected.connect(_on_peer_connected)
                  multiplayer.peer_disconnected.connect(_on_peer_disconnected)</code></pre>

                        <p>
                            Le client, lui, se connecte et instancie son joueur local directement :
                        </p>

                        <pre><code >func start_client(ip):
                  var peer = ENetMultiplayerPeer.new()
                  var error = peer.create_client(ip, PORT)
                  if error:
                      print("Erreur client : ", error)
                      return
                  multiplayer.multiplayer_peer = peer
                  multiplayer.peer_connected.connect(_on_peer_connected)
                  multiplayer.peer_disconnected.connect(_on_peer_disconnected)
                  spawn_player(multiplayer.get_unique_id())</code></pre>

                        <h6>👾 Spawning & autorité</h6>

                        <p>
                            Dès qu’un joueur rejoint, on crée une instance de son personnage avec une autorité réseau
                            unique
                            (son ID) :
                        </p>

                        <pre><code >func spawn_player(id):
                  var player_scene = load("res://player.tscn")
                  var player = player_scene.instantiate()
                  player.name = str(id)
                  player.position = Vector3(randi_range(-5, 5), 1.5, randi_range(-5, 5))
                  var root = get_tree().root.get_node("Node3D")
                  root.add_child(player)
                  players[id] = player
                  player.set_multiplayer_authority(id)</code></pre>

                        <h6>📡 Synchronisation et RPCs</h6>

                        <p>
                            Pour que les positions des joueurs soient partagées entre tous les clients, j’ai mis en
                            place un
                            système de synchronisation
                            manuelle à base de RPCs.
                        </p>

                        <p>
                            D'abord, seul le client qui possède l'autorité réseau sur son personnage (souvent lui-même)
                            envoie sa position :
                        </p>

                        <pre><code >func _physics_process(delta):
                  if multiplayer.get_unique_id() == get_multiplayer_authority():
                      ...
                      rpc("update_position", position, rotation)</code></pre>

                        <p>
                            Et côté réception, tous les autres clients mettent à jour leur version du joueur :
                        </p>

                        <pre><code >@rpc("any_peer", "call_remote")
              func update_position(pos, rot):
                  if multiplayer.get_unique_id() != get_multiplayer_authority():
                      position = pos
                      rotation = rot</code></pre>

                        <h6>📌 Quelques précisions sur les annotations @rpc</h6>

                        <p>
                            La magie dans tout ça, ce sont les annotations <code>@rpc</code>. C’est ce qui rend une
                            fonction
                            appelable à distance.
                            Tu peux préciser plusieurs choses :
                        </p>

                        <ul>
                            <li><code>@rpc("any_peer")</code> : signifie que cette méthode peut être appelée par
                                n’importe
                                quel peer, pas uniquement le serveur.</li>
                            <li><code>@rpc("authority")</code> : seule l’autorité du nœud peut appeler la fonction à
                                distance.</li>
                            <li><code>@rpc("call_remote")</code> : force à exécuter la fonction uniquement sur les
                                autres
                                peers, pas localement.</li>
                        </ul>

                        <p>
                            Donc dans notre cas, <code>@rpc("any_peer", "call_remote")</code> permet à chaque joueur
                            d’envoyer sa position aux autres, mais
                            de ne pas exécuter <code>update_position()</code> sur lui-même. C’est super utile pour
                            éviter
                            les doublons ou les comportements bizarres.
                        </p>

                        <h6>🧱 Prochaine étape</h6>

                        <p>
                            Là, tout le monde peut se déplacer mais seul le serveur voit les deux en même temps (peut
                            être
                            car j'aurais du créer un troisième projet client). C’est fluide, pas de désynchro visible.
                            Prochaine étape :
                            rendre l’environnement interactif (casser, poser des blocs, etc).
                        </p>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">Destruction & Rebuild de murs</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 15 avril 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            Nouvelle fonctionnalité testée : la possibilité de détruire un mur quand on vise dessus et
                            qu'on est assez proche,
                            puis de le reconstruire au même endroit avec une autre touche.
                        </p>

                        <h6>🎮 Objectif</h6>
                        <ul>
                            <li>Interaction au clic clavier selon la distance et la visée.</li>
                            <li>Masquage visuel (<code>hide()</code>) et désactivation de collision.</li>
                            <li>Possibilité de restaurer l’objet au même endroit.</li>
                        </ul>

                        <h6>👁️ Détection du regard + distance</h6>
                        <p>
                            J’utilise un raycast depuis la souris pour savoir si le joueur "vise" bien le mur.
                            On vérifie aussi qu’il est assez proche via la distance 3D.
                        </p>

                        <pre><code >func is_aimed_by_mouse() -> bool:
                  var mouse_pos = get_viewport().get_mouse_position()
                  var ray_origin = camera.project_ray_origin(mouse_pos)
                  var ray_direction = camera.project_ray_normal(mouse_pos)
                  var ray_end = ray_origin + ray_direction * 100.0
                  var query = PhysicsRayQueryParameters3D.create(ray_origin, ray_end)
                  query.collision_mask = 1
                  var result = get_world_3d().direct_space_state.intersect_ray(query)
                  
                  if not is_destroyed:
                      return result and result.collider == self
                  else:
                      if result:
                          var hit_point = result.position
                          return hit_point.distance_to(original_position) < aim_tolerance
                  return false</code></pre>

                        <h6>🧱 Fonctionnement</h6>
                        <p>
                            Le mur est un <code>StaticBody3D</code> avec un collider. Il peut être caché et désactivé
                            (simulation de "détruit"), ou visible et actif ("reconstruit").
                        </p>

                        <pre><code >func destroy_wall():
                  hide()
                  $WallCollision.disabled = true
                  is_destroyed = true
              
              func rebuild_wall():
                  show()
                  $WallCollision.disabled = false
                  global_transform.origin = original_position
                  is_destroyed = false</code></pre>

                        <h6>🧒 Interaction du joueur</h6>
                        <p>
                            La touche <code>destroy_wall</code> permet de détruire si on vise bien, assez proche, et que
                            le mur est encore debout.
                            Inversement pour <code>rebuild_wall</code>.
                        </p>

                        <pre><code >func _process(delta):
                  if Input.is_action_just_pressed("destroy_wall") and not is_destroyed and distance_to_player < interaction_distance and is_aimed:
                      destroy_wall()
                  if Input.is_action_just_pressed("rebuild_wall") and is_destroyed and distance_to_player < interaction_distance and is_aimed:
                      rebuild_wall()</code></pre>

                        <h6>🧬 Instanciation de plusieurs murs</h6>
                        <p>
                            Je me suis aussi penché sur comment instancier plusieurs murs dynamiquement dans la scène.
                            J'ai donc instancié le noeud Wall et j'ai crée un noeud Walls qui appelle des instances de
                            Wall.
                            Ainsi sous "Walls", j'ai un enfant "Wall1" et un enfant "Wall2"
                            Ça ouvre la voie à une vraie base de construction, avec placement dynamique, interaction,
                            destruction, etc.
                        </p>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">Ajout de l'inventaire et gestion de ressources</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 16 avril 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            Afin de renforcer la mécanique de jeu autour de la construction et la destruction,
                            un système d'inventaire simple a été intégré. Le joueur peut désormais récupérer des
                            ressources
                            en détruisant certains éléments du décor, puis les réutiliser pour reconstruire ces mêmes
                            éléments.
                            Chaque action a un coût ou un bénéfice clair, ce qui introduit une logique de gestion légère
                            mais stratégique.
                        </p>

                        <h6>🎒 Ajout de ressources au joueur</h6>
                        <p>
                            Quand un mur est détruit, on ajoute une ressource au joueur. La méthode suivante a été
                            ajoutée dans <code>player.gd</code>.
                        </p>
                        <pre><code>func add_resources(amount):
                    resources += amount
                    print("Resources:", resources)</code></pre>

                        <h6>📊 Affichage dans l'UI</h6>
                        <p>
                            Le script <code>ui.gd</code> met à jour dynamiquement un label affichant le nombre
                            actuel de ressources.
                        </p>
                        <pre><code>extends Control
                
                @export var player: Node3D
                @onready var resource_label = $ResourceLabel
                
                func _process(delta):
                    if player:
                        resource_label.text = "Resources: " + str(player.resources)</code></pre>

                        <h6>🧱 Détruire et reconstruire en consommant</h6>
                        <p>
                            Voici les méthodes intégrées à <code>wall.gd</code> qui gèrent la récupération ou
                            l'utilisation des ressources.
                        </p>
                        <pre><code>func destroy_wall():
                    hide()
                    $WallCollision.disabled = true
                    is_destroyed = true
                    player.add_resources(1)  # Donne 1 ressource au joueur
                
                func rebuild_wall():
                    if player.resources >= 1:  # Nécessite 1 ressource
                        show()
                        $WallCollision.disabled = false
                        global_transform.origin = original_position
                        is_destroyed = false
                        player.resources -= 1
                        print("Wall rebuilt, resources left:", player.resources)</code></pre>

                        <h6>🧠 Logique derrière</h6>
                        <ul>
                            <li><strong>Détruire</strong> rapporte 1 ressource au joueur.</li>
                            <li><strong>Reconstruire</strong> consomme 1 ressource si le joueur en possède au moins une.
                            </li>
                            <li>La reconstruction se fait exactement à l'emplacement d'origine, avec collision
                                réactivée.</li>
                        </ul>

                        <p>
                            Ce système forme les bases d’un gameplay orienté “base building” où les ressources ont de la
                            valeur,
                            et chaque action a un coût réel.
                        </p>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">🌳 Ajout d’un arbre 3D destructible</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 18 avril 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            Extension naturelle du système de murs destructibles : j’ai ajouté un arbre 3D avec un
                            <code>.obj</code> + <code>.mtl</code> en guise de mesh. L’arbre fonctionne comme un mur : il
                            peut être détruit pour récolter des ressources (2 au total), et reconstruit si le joueur a
                            au moins 1 ressource.
                        </p>

                        <div class="ratio ratio-16x9 mb-4">
                            <video controls>
                                <source src="../videos/arbre_demo.mp4" type="video/mp4" />
                                Votre navigateur ne supporte pas la lecture de vidéos.
                            </video>
                        </div>

                        <h6>🗂️ Ressources .obj / .mtl</h6>
                        <p>
                            J’ai importé un modèle d’arbre avec un fichier <code>tree.obj</code> accompagné de son
                            <code>tree.mtl</code> pour la texture. Le node racine est un <code>StaticBody3D</code> comme
                            pour les murs.
                        </p>

                        <h6>🪓 Récolte & reconstruction</h6>
                        <p>
                            Quand le joueur détruit l’arbre, il obtient <strong>2 ressources</strong>. Pour le
                            reconstruire, une seule ressource est nécessaire. Le comportement est presque identique au
                            mur, répliqué dans un nouveau script dédié.
                        </p>

                        <h6>👁️ Interaction avec la souris</h6>
                        <p>
                            Comme pour les murs, la visée se fait avec un raycast depuis la souris. On vérifie la
                            distance et l’alignement avec l’objet avant de permettre la destruction ou la
                            reconstruction.
                        </p>

                        <h6>🧪 Prochaine étape ?</h6>
                        <p>
                            Le système étant déjà modulaire, il sera facile d’ajouter d’autres éléments récoltables dans
                            le monde (roches, plantes…). Chaque élément pourrait avoir son propre coût/bénéfice, ouvrant
                            la voie à un mini système de craft.
                        </p>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">🧬 Virage de projet : de BaseX à Sporyx</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 22 avril 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            BaseX devait être un projet ambitieux mêlant construction, multijoueur et interactions
                            complexes. Ce blog lui était d'ailleurs consacré.
                            Mais la densité de la tâche a clairement freiné la progression. Plutôt que de rester bloqué,
                            j’ai décidé
                            de prendre un virage stratégique pour concrétiser plus rapidement une version jouable.
                        </p>

                        <h6>📱 Sporyx : une version mobile plus light</h6>
                        <p>
                            Sporyx est né de cette envie de simplifier : un jeu mobile, basé sur les fondations que j’ai
                            posées avec BaseX,
                            mais allégé en complexité. L’idée ? Un gameplay centré sur :
                        </p>
                        <ul>
                            <li>🧭 Exploration de zones asynchrone</li>
                            <li>⚔️ PVP asynchrone entre joueurs</li>
                            <li>🧪 Mutations, spores, ressources et évolution</li>
                        </ul>

                        <h6>🔁 Ce que je garde de BaseX</h6>
                        <p>
                            Même si je change de cap, beaucoup de mécaniques restent utiles :
                        </p>
                        <ul>
                            <li>Le système de ressources et d'inventaire</li>
                            <li>Tout le principe asnchrone</li>
                        </ul>

                        <h6>🚀 Objectif à court terme</h6>
                        <p>
                            Sporyx doit me permettre de livrer rapidement une version testable.C’est aussi un bon
                            terrain d’expérimentation pour toutes les idées que je
                            voulais implémenter dans BaseX mais de façon plus légère.
                        </p>

                        <blockquote class="blockquote">
                            "Mieux vaut un petit jeu fini qu’un grand projet qui dort dans un dossier."
                        </blockquote>

                        <p class="mt-3">
                            À suivre très vite avec les premiers éléments visuels de Sporyx.
                        </p>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">🚧 Premiers pas visuels sur Sporyx</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 23 avril 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            C’est officiel : Sporyx est lancé ! 🎉 Le tout premier prototype prend forme avec un menu
                            simple
                            et un personnage en 3D visible à gauche de l’écran. L’idée ici est d’explorer le layout
                            général,
                            avec une interface épurée adaptée à un jeu mobile.
                        </p>

                        <h6>👁️ Prototype du menu</h6>
                        <p>
                            J’ai positionné trois boutons à droite de l’écran, servant pour l’instant de placeholder
                            pour le futur menu (inventaire, exploration, arène). À gauche, un personnage en 3D
                            s'affiche
                            dans une pose idle. Ce prototype me permet de tester l'ergonomie sur écran tactile.
                        </p>

                        <div class="row g-3 mb-3">
                            <div class="col-md-4">
                                <a href="#" onclick="showImageInModal('../images/proto1.png'); return false;">
                                    <img src="../images/proto1.png" class="img-fluid rounded border"
                                        alt="Prototype Sporyx 1">
                                </a>
                            </div>
                            <div class="col-md-4">
                                <a href="#" onclick="showImageInModal('../images/proto2.png'); return false;">
                                    <img src="../images/proto2.png" class="img-fluid rounded border"
                                        alt="Prototype Sporyx 2">
                                </a>
                            </div>
                            <div class="col-md-4">
                                <a href="#" onclick="showImageInModal('../images/proto3.png'); return false;">
                                    <img src="../images/proto3.png" class="img-fluid rounded border"
                                        alt="Prototype Sporyx 3">
                                </a>
                            </div>
                        </div>

                        <h6>🎨 Problèmes actuels</h6>
                        <ul>
                            <li>Le personnage passe parfois derrière le fond 2D quand j’essaie de styliser l’UI.</li>
                            <li>Pas encore de vraie navigation fonctionnelle entre les menus.</li>
                            <li>Besoin de définir une direction artistique cohérente (fond, éclairage, typos, couleurs).
                            </li>
                        </ul>

                        <h6>🛠️ Prochaine étape</h6>
                        <p>
                            Je vais retravailler la structure du menu pour qu’il soit à la fois utilisable et stylé. Je
                            vais
                            probablement mixer des éléments 2D (UI) et 3D (personnage central) sur un fond personnalisé.
                            Je tenterai aussi un full 3D si c'est plus simple et cohérent.
                        </p>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">🖼️ Tests de fond dans Sporyx</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 24 avril 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            Petite session de test visuel aujourd’hui : j’ai essayé différents types de fond derrière le
                            personnage principal.
                            L’idée était de trouver un rendu sympa et lisible sur mobile, sans nuire à la lisibilité de
                            l’UI ni noyer l’action.
                        </p>

                        <h6>🎨 Fond 2D</h6>
                        <p>
                            Premier test avec un fond 2D fixe. En théorie, c’est simple, léger et joli… mais dans la
                            pratique, j’ai eu des soucis.
                            Le personnage 3D passait parfois derrière, probablement un souci de couche ou de CanvasLayer
                            mal configuré.
                        </p>
                        <div class="text-center mb-3">
                            <a href="#" onclick="showImageInModal('../images/fond2d-test.png'); return false;">
                                <img src="../images/fond2d-test.png" class="img-fluid rounded border"
                                    alt="Test fond 2D">
                            </a>
                        </div>

                        <h6>🌌 Fond 3D</h6>
                        <p>
                            Deuxième essai avec un environnement 3D très simple en arrière-plan. Le rendu est un peu
                            plus cohérent pour
                            le moment, mais je ne suis pas encore convaincu à 100%. Il faudra tester avec des assets
                            plus stylisés.
                        </p>
                        <div class="text-center mb-3">
                            <a href="#" onclick="showImageInModal('../images/fond3d-test.png'); return false;">
                                <img src="../images/fond3d-test.png" class="img-fluid rounded border"
                                    alt="Test fond 3D">
                            </a>
                        </div>

                        <h6>🔄 Prochaine étape</h6>
                        <p>
                            Prochain focus : améliorer l’inventaire du joueur, le rendre plus lisible et fonctionnel
                            dans l’interface de jeu.
                        </p>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">🌀 Réflexion : Vers un Sporyx 100% 2D ?</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 24 avril 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            Petite pause conceptuelle aujourd’hui. Après plusieurs tests en 3D (personnage, fond,
                            environnement), je me pose sérieusement la question : est-ce que ça vaut vraiment le coup de
                            continuer en 3D ? 🤔
                        </p>

                        <h6>🎭 La 3D : quels avantages ?</h6>
                        <p>
                            Le personnage en 3D donne une belle profondeur et un style visuel un peu plus “premium”...
                            mais c’est aussi le seul élément du jeu actuellement à utiliser la 3D. Le reste (interface,
                            menus, fonds) est à dominante 2D. Et en jeu mobile, la lisibilité prime.
                        </p>

                        <h6>🖌️ Pourquoi envisager la 2D ?</h6>
                        <ul>
                            <li>Plus simple à gérer techniquement (pas de souci de couches, de caméra ou de lumière).
                            </li>
                            <li>Meilleure performance sur des appareils mobiles moins puissants.</li>
                            <li>Direction artistique plus cohérente si tout est 2D.</li>
                            <li>Le personnage pourrait être redessiné en sprite stylisé ou animé avec Spine ou Godot
                                directement.</li>
                        </ul>

                        <h6>💭 Conclusion provisoire</h6>
                        <p>
                            Rien n’est encore décidé, mais je penche de plus en plus vers une DA 2D complète. Sporyx est
                            un jeu mobile avant tout, et la 2D permettrait de se concentrer sur le gameplay et
                            l’identité graphique sans trop se disperser.
                        </p>

                        <p class="fst-italic text-muted">Affaire à suivre très bientôt… 👀</p>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">🌐 Communication Godot ↔ Serveur Java (Ping → Pong)</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 29 avril 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            J’ai mis en place une communication simple entre <strong>Godot</strong> et un
                            <strong>serveur Java local</strong>, pour poser les bases de futures interactions réseau
                            (arène, échanges, etc.).
                        </p>

                        <h6>🔧 Côté serveur (Java)</h6>
                        <p>Le serveur Java écoute sur le port <code>8080</code> et répond "pong" quand il reçoit une
                            requête <code>GET /ping</code> :</p>
                        <pre><code>ServerSocket serverSocket = new ServerSocket(8080);
                  Socket clientSocket = serverSocket.accept();
                  BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                  String requestLine = in.readLine(); // Ex: "GET /ping HTTP/1.1"
                  ...
                  if (requestLine.startsWith("GET /ping")) {
                      out.println("pong");
                  }
                  </code></pre>

                        <h6>🎮 Côté client (Godot)</h6>
                        <p>Dans Godot, j’utilise un <code>HTTPRequest</code> pour envoyer la requête <em>quand le bouton
                                "Arène"</em> est pressé :</p>

                        <pre><code>func _on_arena_button_pressed():
                      arena_ui.visible = true
                      send_ping_request()
                  
                  func send_ping_request():
                      var http_request = HTTPRequest.new()
                      add_child(http_request)
                      http_request.request_completed.connect(_on_request_completed)
                      http_request.request("http://localhost:8080/ping")
                  
                  func _on_request_completed(result, response_code, headers, body):
                      if response_code == 200:
                          var response = body.get_string_from_utf8()
                          arena_ui.update_response(response)
                  </code></pre>

                        <p>
                            Le label dans l’interface Arène est ensuite mis à jour avec la réponse du serveur, ce qui
                            permet d’afficher dynamiquement le <code>"pong"</code> retourné.
                        </p>

                        <h6>🖼️ Interface Godot (Aperçu)</h6>
                        <p>Un aperçu du panneau Arène dans Godot :</p>
                        <ul>
                            <li>Un bouton "Défier un joueur"</li>
                            <li>Un <code>Label</code> affichant "En attente de réponse..." ou "Réponse du serveur :
                                pong"</li>
                        </ul>

                        <h6>🎥 Démo vidéo</h6>
                        <div class="ratio ratio-16x9 mb-3">
                            <iframe src="../videos/test_server.mp4" title="Ping-Pong Godot/Java"
                                allowfullscreen></iframe>
                        </div>

                        <h6>🔭 Ce que ça ouvre</h6>
                        <ul>
                            <li>Début d’une logique serveur pour le combat ou la gestion de données persistantes</li>
                            <li>Test réseau simple sans WebSocket ni base de données</li>
                            <li>Possibilité d’étendre ça à une arène asynchrone ou des envois de stats</li>
                        </ul>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">⚔️ Faux combat Godot ↔ Java : simulateur en local</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 01 mai 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            Après le test de communication simple entre Godot et un serveur Java (ping → pong), j’ai
                            implémenté un <strong>simulateur de combat</strong>.
                            Le client Godot envoie les stats du joueur en JSON, et le serveur Java simule un
                            affrontement contre un adversaire généré dynamiquement.
                        </p>

                        <h6>🔧 Côté serveur (Java)</h6>
                        <p>
                            Le serveur écoute toujours sur <code>8080</code> et répond maintenant à une requête
                            <code>POST /fight</code> avec un résultat de combat :
                        </p>
                        <pre><code>else if (requestLine.startsWith("POST /fight")) {
                      responseBody = simulateFight(body.toString());
                  }</code></pre>

                        <p>La méthode <code>simulateFight()</code> parse les stats du joueur, génère un adversaire aux
                            stats proches, et boucle jusqu'à la victoire ou la défaite :</p>

                        <pre><code>int opponentHp = playerHp + rand.nextInt(5) - 2;
                  int opponentAttack = playerAttack + rand.nextInt(3) - 1;
                  
                  while (playerHp > 0 && opponentHp > 0) {
                      if (rand.nextFloat() > 0.3) {
                          int damage = playerAttack + rand.nextInt(3) - 1;
                          opponentHp -= damage;
                      }
                      // puis l’adversaire attaque à son tour…
                  }
                  
                  return (playerHp > 0) ? "Vous avez gagné !" : "Vous avez perdu !";</code></pre>

                        <h6>🎮 Côté client (Godot)</h6>
                        <p>
                            L’interface Arène affiche les stats du joueur et un bouton "Défier un joueur". Lors du clic,
                            une requête <code>POST</code> est envoyée avec les stats en JSON.
                        </p>

                        <pre><code>func _on_challenge_button_pressed():
                      var player_stats = {"hp": 10, "attack": 3}
                      emit_signal("fight_request", player_stats)
                  
                  func update_response(response):
                      $Panel/VBoxContainer/ResponseLabel.text = response</code></pre>

                        <p>
                            La requête est traitée par un script global via le signal <code>fight_request</code>, qui
                            déclenche un <code>HTTPRequest</code> vers <code>http://localhost:8080/fight</code> avec les
                            données du joueur.
                        </p>

                        <h6>🖼️ Interface Godot (Aperçu)</h6>
                        <ul>
                            <li>Label <code>Joueur : HP 10, Attaque 3</code></li>
                            <li>Label <code>Adversaire : HP 10, Attaque 3</code> (modifiable dynamiquement)</li>
                            <li>Bouton <strong>Défier un joueur</strong></li>
                            <li>Label réponse : <code>"En attente de réponse..."</code> → <em>"Vous avez gagné !"</em>
                            </li>
                        </ul>

                        <h6>🔭 Ce que ça ouvre</h6>
                        <ul>
                            <li>Simulations côté serveur : combats, tour par tour, stats</li>
                            <li>Évolution possible : buffs, critiques, stats variées</li>
                            <li>Architecture client-serveur pour un jeu PvP (async)</li>
                        </ul>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">⚔️ Combat dynamique Godot ↔ Serveur Java</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 01 mai 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            Après avoir mis en place un premier test, j’ai enrichi la communication entre Godot et le
                            serveur Java pour gérer un <strong>combat tour par tour</strong>, avec génération aléatoire
                            de l’adversaire, affichage des stats et <strong>log en direct du combat</strong>.
                        </p>

                        <h6>🎮 Côté client (Godot)</h6>
                        <p>
                            Dans Godot, une UI simple permet de déclencher le combat avec un bouton, affiche les stats
                            du joueur et de l’adversaire, et met à jour dynamiquement le <code>TextEdit</code> contenant
                            le log :
                        </p>

                        <pre><code>func _on_challenge_button_pressed():
                      var player_stats = {"hp": 10, "attack": 3}
                      $CombatLog.text = "Combat en cours...\n"
                      emit_signal("fight_request", player_stats)
                  
                  func update_response(response):
                      $CombatLog.text = response
                  
                  func update_opponent_stats(hp, attack):
                      $OpponentStats.text = "Adversaire : HP %d, Attaque %d" % [hp, attack]
                      </code></pre>

                        <p>
                            L’interface comprend :
                        </p>
                        <ul>
                            <li>Un bouton <strong>"Défier un joueur"</strong></li>
                            <li>Deux <code>Label</code> pour les stats du joueur et de l’adversaire</li>
                            <li>Un <code>TextEdit</code> non éditable qui affiche le log du combat</li>
                        </ul>

                        <h6>🧠 Simulation du combat (côté serveur)</h6>
                        <p>
                            Le combat est simulé tour par tour avec des chances d’échec (~30%) et des dégâts
                            semi-aléatoires (±1). Le log du combat détaille chaque action :
                        </p>

                        <pre><code>Début du combat !
                  Joueur: HP=10, Attaque=3
                  Adversaire: HP=9, Attaque=2
                  ---
                  Joueur inflige 2 dégâts ! Adversaire a 7 HP.
                  Adversaire inflige 3 dégâts ! Joueur a 7 HP.
                  Joueur rate son attaque !
                  Adversaire inflige 2 dégâts ! Joueur a 5 HP.
                  ...
                  Vous avez gagné !
                      </code></pre>

                        <h6>🔭 Ce que ça ouvre</h6>
                        <ul>
                            <li>Affichage dynamique du combat dans l’interface</li>
                            <li>Réutilisable pour du PvP ou du PvE</li>
                            <li>Facilement extensible : XP, compétences, équipements...</li>
                        </ul>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">🌍 Centralisation et Refactorisation de l’Exploration dans Sporyx</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 04 mai 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            Aujourd’hui, nous avons fait évoluer Sporyx en centralisant toutes les données d’exploration
                            côté serveur et en refactorisant le code Java pour le rendre plus modulaire et maintenable.
                            Voici un résumé des améliorations apportées.
                        </p>

                        <h6>🔧 Côté serveur (Java) : Centralisation des données</h6>
                        <p>
                            Nous avons déplacé toutes les informations sur les mondes (noms, descriptions, rencontres
                            possibles, loots) dans <code>ExplorationManager.java</code>. Le client ne stocke plus rien
                            localement et récupère tout via des requêtes HTTP. Une nouvelle route
                            <code>GET /worlds</code> a été ajoutée pour fournir la liste des mondes disponibles.
                        </p>

                        <pre><code>private static final Map&lt;String, World&gt; WORLDS = new HashMap&lt;&gt;();
                
                private void initializeWorlds() {
                    WORLDS.put("Mycelic Forest", new World("Mycelic Forest", 
                        "A lush forest filled with giant mushrooms and floating spores.", 
                        List.of("Giant Mushroom", "Floating Spore"), 
                        Map.of("Spores", 5, "Mushroom Cap", 2)));
                    // Autres mondes...
                }
                
                public String getWorldsList() {
                    StringBuilder response = new StringBuilder();
                    response.append("Available worlds:\n");
                    for (String worldName : WORLDS.keySet()) {
                        response.append(worldName).append("\n");
                    }
                    return response.toString();
                }
                        </code></pre>

                        <h6>🎮 Côté client (Godot) : Dynamisation de l’interface</h6>
                        <p>
                            Dans <code>explore.gd</code>, nous avons supprimé la liste statique des mondes. À la place,
                            le client envoie une requête GET à <code>/worlds</code> au démarrage pour récupérer
                            dynamiquement la liste des mondes et remplir la <code>WorldsList</code>.
                        </p>

                        <pre><code>func fetch_worlds_list():
                    var http_request = HTTPRequest.new()
                    add_child(http_request)
                    http_request.request_completed.connect(_on_worlds_request_completed)
                    var error = http_request.request("http://127.0.0.1:8080/worlds")
                
                func _on_worlds_request_completed(result, response_code, headers, body):
                    if response_code == 200:
                        var response = body.get_string_from_utf8()
                        available_worlds = []
                        for line in response.split("\n"):
                            if line != "Available worlds:" and line.strip_edges() != "":
                                available_worlds.append(line.strip_edges())
                                $Panel/VBoxContainer/WorldsList.add_item(line.strip_edges())
                        update_combat_log("Worlds loaded successfully!")
                        </code></pre>

                        <p>
                            L’interface d’exploration comprend maintenant :
                        </p>
                        <ul>
                            <li>Une <code>WorldsList</code> remplie dynamiquement avec les mondes du serveur</li>
                            <li>Un bouton <strong>"Explore"</strong> pour lancer une exploration</li>
                            <li>Un <code>CombatLog</code> qui affiche les résultats après 10 secondes</li>
                        </ul>

                        <h6>🧠 Refactorisation du serveur</h6>
                        <p>
                            Le code Java a été entièrement refactorisé pour séparer les responsabilités.
                            <code>Server.java</code> a été divisé en plusieurs classes : <code>HttpServer</code>,
                            <code>PlayerManager</code>, <code>CombatManager</code>, et <code>ExplorationManager</code>.
                            Les conventions de nommage (camelCase, PascalCase) ont été appliquées.
                        </p>

                        <pre><code>public class HttpServer {
                    private final PlayerManager playerManager;
                    private final CombatManager combatManager;
                    private final ExplorationManager explorationManager;
                
                    public HttpServer() {
                        this.playerManager = new PlayerManager();
                        this.combatManager = new CombatManager(playerManager);
                        this.explorationManager = new ExplorationManager();
                    }
                }
                        </code></pre>

                        <h6>🌟 Améliorations de l’exploration</h6>
                        <p>
                            L’exploration a été enrichie côté serveur avec des mondes plus détaillés (rencontres
                            possibles, loots). Le serveur simule l’exploration pendant 10 secondes et renvoie un
                            résultat complet, comme :
                        </p>

                        <pre><code>Exploration of Mycelic Forest completed!
                A lush forest filled with giant mushrooms and floating spores.
                You found 5 Spores!
                        </code></pre>

                        <h6>🎥 Démo vidéo</h6>
                        <div class="ratio ratio-16x9 mb-3">
                            <iframe src="../videos/explore_and_pvp.mp4" title="Explore and PvP demo"
                                allowfullscreen></iframe>
                        </div>

                        <h6>🔭 Ce que ça ouvre</h6>
                        <ul>
                            <li>Centralisation complète des données : le client est plus léger et dépendant du serveur
                            </li>
                            <li>Facilité d’ajout de nouveaux mondes ou mécaniques côté serveur</li>
                            <li>Prochaine étape : lier les loots (ex. : Spores) à un inventaire côté client</li>
                        </ul>
                    </div>
                </article>

                <article class="mb-5 p-4 border rounded shadow-sm" id="latest-post">
                    <div class="blog-header d-flex justify-content-between align-items-center">
                        <h3 class="h5">🏁 Fin de la démo Sporyx</h3>
                        <button class="btn btn-link toggle-content">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </div>
                    <p class="text-muted small">Publié le 07 mai 2025</p>

                    <div class="blog-content" style="display: none;">
                        <p>
                            Après plusieurs semaines de développement intense, la démo technique de
                            <strong>Sporyx</strong> touche à sa fin. Le projet a bien évolué : système de combat
                            <strong>Godot ↔ Java</strong>, phases d’exploration, refactorisation serveur et intégration
                            propre côté client. Chaque ajout a été l’occasion d’expérimenter, de clarifier la structure,
                            et de poser les bases d’un éventuel futur jeu.
                        </p>

                        <h6>✅ Ce qui a été accompli</h6>
                        <ul>
                            <li>Combat tour par tour entre Godot et serveur Java</li>
                            <li>Exploration asynchrone avec génération procédurale d'événements</li>
                            <li>Interface utilisateur dynamique pour afficher stats et logs</li>
                            <li>Journalisation du combat et affichage en direct</li>
                            <li>Architecture côté serveur découpée en modules (combat, exploration, joueur)</li>
                        </ul>

                        <h6>🧠 Pourquoi s’arrêter ici ?</h6>
                        <p>
                            L’objectif initial était de tester la viabilité d’un échange client-serveur entre un moteur
                            de jeu et un backend Java. Le prototype a atteint ce but, et il est désormais suffisamment
                            complet pour servir de base à un projet plus ambitieux… plus tard.
                        </p>

                        <h6>🚧 Et après ?</h6>
                        <ul>
                            <li>Repartir sur une base plus complète en multijoueur réel</li>
                            <li>Introduire un système de progression : compétences, équipements, génération persistante
                            </li>
                            <li>Explorer davantage l’univers de Sporyx avec lore et mutations évolutives</li>
                        </ul>

                        <p>
                            Merci d’avoir suivi ce petit bout de chemin. La graine a été plantée. 🌱
                        </p>
                    </div>
                </article>

            </section>
        </section>

        <div class="text-center mt-5">
            <a href="../index.html" class="btn btn-outline-secondary">← Retour au portfolio</a>
        </div>

        <div class="modal fade" id="lightboxModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered modal-xl">
                <div class="modal-content bg-dark position-relative p-2">
                    <button type="button" class="btn-close btn-close-white position-absolute top-0 end-0 m-3"
                        data-bs-dismiss="modal" aria-label="Close"></button>
                    <img id="modalImage" src="" class="w-100 rounded" alt="Agrandissement">
                </div>
            </div>
        </div>

        <a href="#latest-post" class="btn btn-primary position-fixed bottom-0 end-0 m-4 shadow">
            📌 Dernier article
        </a>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.28.0/prism.js"></script>
    <script src="https://kit.fontawesome.com/a076d05399.js"></script>
    <script>
        document.querySelectorAll('.toggle-content').forEach(button => {
            button.addEventListener('click', function () {
                const content = this.closest('article').querySelector('.blog-content');
                const icon = this.querySelector('i');
                if (content.style.display === 'none' || content.style.display === '') {
                    content.style.display = 'block';
                    icon.classList.remove('fa-chevron-down');
                    icon.classList.add('fa-chevron-up');
                } else {
                    content.style.display = 'none';
                    icon.classList.remove('fa-chevron-up');
                    icon.classList.add('fa-chevron-down');
                }
            });
        });

        function showImageInModal(imagePath) {
            const modalImg = document.getElementById("modalImage");
            modalImg.src = imagePath;

            const modal = new bootstrap.Modal(document.getElementById("lightboxModal"));
            modal.show();
        }

        document.querySelectorAll('a[href="#latest-post"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.getElementById("latest-post");
                if (target) {
                    target.scrollIntoView({ behavior: "smooth" });
                }
            });
        });
    </script>
    <script src="../script/navigation.js"></script>
</body>

</html>